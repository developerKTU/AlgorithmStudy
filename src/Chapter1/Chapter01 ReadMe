1. 시간복잡도 : 주어진 문제를 해결하기 위한 연산횟수 (1억번 연산 = 1초)
2. 문제에서는 시간제한으로 주어짐.
3. 시간복잡도는 알고리즘 선택의 기준이 된다.

4. 시간복잡도 표기법
    - 빅 오메가 (최상) : 한번만에 찾는 경우 (1) -> 랜덤 숫자가 0이 나오는 경우 딱 for문을 딱 한번만 수행
    - 빅 세타 (평균) : 50번 정도의 연산 (N/2) -> 랜덤 숫자가 50이 나오는 경우 딱 for문을 절반만 수행
    - 빅오 (최악) : 100번 연산 (N) -> 랜덤 숫자가 99가 나오는 경우 그러면 0부터 99까지 for문을 다 수행함
    - 코딩테스트땐 빅오 표기법으로 사용한다. (항상 최악의 상황을 염두에 두고 코딩)

5. 시간복잡도 특징
    - 알고리즘에는 다양한 시간복잡도를 가지고 있음 (N!, NlogN, 2^N 등등...)
    - 상수는 시간복잡도 계산에서 제외된다.
    - 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

6. 알고리즘 선정 방법 예시
    - 특정 데이터 구간의 정렬 문제가 주어짐.
    - 문제에 주어진 데이터 갯수를 확인 (Ex. 1 <= N <= 1,000,000)
    - 문제에 주어진 제한시간 확인 (Ex. 2초 -> 2억번 이하의 연산횟수를 활용)
    - 연산횟수(제한시간) = 알고리즘 시간복잡도 X 데이터의 크기
    - 버블정렬의 시간복잡도 (N^2) : (1,000,000)^2 > 200,000,000(2초) 부접합 알고리즘
    - 병합정렬의 시간복잡도 (logN) : (1,000,000)log(1,000,000) < 2,000,000,000 적합한 알고리즘

7. 시간복잡도를 활용하는 이유
    - 알맞은 알고리즘쓰기 (알맞은 알고리즘을 선택하는 기준이 됨)
    - 비효율적인 로직(중첩된 for문 등 가장 시간복잡도를 많이 잡아먹는 곳) 찾아서 효울적인 로직으로 수정