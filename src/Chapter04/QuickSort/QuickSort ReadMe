※ 퀵정렬

1. 개요
    - 기준값 (피벗)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 과정을 반복하여
      정렬하는 알고리즘.
    - 기준값이 어떻게 선정되는지에 따라 시간복잡도에 많은 영향을 미침.
    - 퀵정렬은 코드 구현이 다소 어렵다.
    - 코딩테스트에서 종종 나오는 문제.

2. 시간복잡도
    - 최악 시간복잡도는 O(n^2)이다. (진짜 운 나쁠때 나오는 시간복잡도)
    - 퀵정렬의 시간복잡도는 불규칙하다. (피벗데이터가 항상 다르기 때문에)
    - 평균 시간복잡도는 O(nlogn)이다.

3. 핵심이론
    - 피벗을 중심으로 두 개의 집합으로 나누어 정렬한다.
    - 피벗을 너무 한쪽으로 치우쳐 선정하게 되면 성능면에서 저하됨.
    - 중앙값에 가까운 피벗값을 선택하는 것이 좋음.
      (주로 배열의 첫번째, 마지막, 중앙값 중 크기가 중간인 값을 피벗으로 선정함.)

4. 정렬 과정
    ①   데이터를 분할하는 피벗을 선정한다.
    ②-1 start가 가리키는 데이터가 피벗데이터보다 작으면 start포인터를 오른쪽으로 한칸 이동
    ②-2 end가 가리키는 데이터가 피벗데이터보다 크면 end포인터를 왼쪽으로 한칸 이동
    ②-3 (start가 가리키는 데이터 > 피벗데이터) && (end가 가리키는 데이터 < 피벗데이터)
         ==> 각각의 데이터를 swap 후, start는 오른쪽, end는 왼쪽으로 1칸씩 이동.
    ②-4 end가 start보다 작아질때까지 (end가 start 왼쪽에 위치할때까지) ②-1 ~ ②-3 과정 반복
    ②-5 end가 start보다 작아지면 (end가 start 왼쪽에 위치하면)
         피벗데이터와 end데이터를 swap한 후 알고리즘 종료. (피벗데이터가 원래 위치로 돌아간 상태)
    ②-6 start와 end가 같이 기리키는 데이터 < 피벗데이터 : start와 end가 만난지점의 오른쪽에 피벗데이터 삽입
         (해당 배열은 피벗데이터보다 무조건 큰 데이터만 삽입.)
         start와 end가 같이 기리키는 데이터 > 피벗데이터 : start와 end가 만난지점의 왼쪽에 피벗데이터 삽입
         (해당 배열은 피벗데이터보다 무조건 작은 데이터만 삽입.)
    ③   분리된 배열에서 각각 피벗 선정
    ④   분리 배열이 1개 이하가 될 때까지 ① ~ ③ 과정 반복.